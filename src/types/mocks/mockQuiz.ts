import type {MCQuizDTO} from "../MCQuizDTO";

export const mockQuiz: MCQuizDTO = {
	questions: [
		{
			question: "You have a multi-threaded Java application where you need to execute a task in parallel and ensure that after the task is completed, a report is generated by the main thread. Given the following methods, which one should you use to ensure the main thread waits for the parallel task to complete before proceeding?",
			possibleAnswers: [
				"Thread.start()",
				"Thread.yield()",
				"Thread.join()",
				"Thread.isAlive()"
			],
			correctAnswerIndex: 2,
			explanation: "The Thread.join() method is used to make the main thread wait for the completion of the other thread. This ensures that the main thread will not proceed to generate the report until the parallel task is finished."
		},
		{
			question: "In a scenario where you have multiple threads accessing and updating a shared counter variable, you notice inconsistencies in the final count. Which approach should you use to avoid these race conditions?",
			possibleAnswers: [
				"Use Thread.setName() to identify threads",
				"Implement Runnable instead of extending Thread",
				"Use synchronized methods for accessing the counter",
				"Create a supervisor thread to monitor the counter"
			],
			correctAnswerIndex: 2,
			explanation: "The synchronized keyword is used in Java to prevent race conditions by ensuring that only one thread can access the method that updates the shared counter at a time."
		},
		{
			question: "You are tasked with creating a Java application where a background thread needs to periodically check if a file download is complete while the main application continues executing. How can you implement this periodic check?",
			possibleAnswers: [
				"Use Thread.yield() within the background thread",
				"Implement a supervisor thread that uses isAlive()",
				"Use a synchronized block to check the file status",
				"Call Thread.join() in the main thread"
			],
			correctAnswerIndex: 1,
			explanation: "A supervisor thread can be used to monitor the status of another thread using the isAlive() method. This allows the background thread to periodically check if the file download thread is still running and report its status."
		},
		{
			question: "In a Java application, you need to perform a computation in a separate thread, but you prefer not to create a new class for this task. What is the most concise way to achieve this using modern Java syntax?",
			possibleAnswers: [
				"Extend the Thread class and override the run() method",
				"Implement the Runnable interface in a new class",
				"Use a lambda expression with a new Thread instance",
				"Use Thread.setDaemon() to run it as a background task"
			],
			correctAnswerIndex: 2,
			explanation: "Using a lambda expression with a new Thread instance allows you to define the run() method inline without creating a new class or explicitly implementing the Runnable interface, making it the most concise modern Java syntax for this task."
		},
		{
			question: "You have a Java application where two threads must coordinate their execution based on a shared condition. Which methods would you use to achieve this coordination?",
			possibleAnswers: [
				"Thread.yield() and Thread.sleep()",
				"wait() and notifyAll() within a synchronized block",
				"Thread.interrupt() and Thread.join()",
				"Thread.setPriority() and Thread.isAlive()"
			],
			correctAnswerIndex: 1,
			explanation: "The wait() and notifyAll() methods are used for thread coordination based on a shared condition. They must be used within a synchronized block to ensure that the condition checks and notifications are thread-safe."
		}
	]
};
